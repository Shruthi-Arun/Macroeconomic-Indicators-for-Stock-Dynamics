# -*- coding: utf-8 -*-
"""VAR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1d_M47PDm35M_IV0BI3eY11xX_X1IIF_Z

# MODEL 1
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.api import VAR
from statsmodels.stats.stattools import durbin_watson
from statsmodels.tsa.stattools import adfuller
from sklearn.metrics import mean_squared_error, mean_absolute_error
import scipy.stats as stats

"""## Pre procc"""

df = pd.read_csv('macro_data_cleaned.csv')
print(df.columns)

# converting Unnamed0 to date
df = pd.read_csv('macro_data_cleaned.csv')
print(df.columns)

df = df.rename(columns={'Unnamed: 0': 'Date'})

# Convert to datetime and set as index
df['Date'] = pd.to_datetime(df['Date'])
df = df.set_index('Date')

df.info()

df.head()

print(df.isnull().sum())
print(df.isnull().sum().sum())

df = df.dropna()

"""## VAR"""

data = df.copy()

for col in ['GDP', 'Industrial_Output', 'Money_Supply']:
    if (data[col] <= 0).any():
        data[f'logdiff_{col}'] = data[col].diff()
    else:
        data[f'logdiff_{col}'] = np.log(data[col]).diff()

data['diff_Inflation'] = data['Inflation'].diff()
data['diff_Interest_Rate'] = data['Interest_Rate'].diff()
data['diff_Treasury_Yield'] = data['Treasury_Yield'].diff()

data['Unemployment'] = data['Unemployment']
data['Consumer_Confidence'] = data['Consumer_Confidence']
data['SP500'] = data['SP500_Returns']

vars_for_var = [
    'diff_Inflation', 'Unemployment', 'diff_Interest_Rate',
    'logdiff_GDP', 'logdiff_Industrial_Output', 'logdiff_Money_Supply',
    'Consumer_Confidence', 'diff_Treasury_Yield', 'SP500'
]

Y = data[vars_for_var].dropna()
print("Final stationary dataset shape:", Y.shape)
display(Y.head())

model = VAR(Y)
lag_results = model.select_order(maxlags=12)
print(lag_results.summary())

optimal_lag = 3
var_model = model.fit(optimal_lag)
print(var_model.summary())

irf = var_model.irf(10)
responses = var_model.names
impulses = var_model.names

ncols = 4
n_plots = len(responses) * len(impulses)
nrows = (n_plots + ncols - 1) // ncols

fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=(16, nrows * 3))
axes = axes.flatten()

plot_idx = 0
for impulse in impulses:
    for response in responses:
        ax = axes[plot_idx]
        data = irf.irfs[:, responses.index(response), impulses.index(impulse)]
        ax.plot(np.arange(len(data)), data, color="C0")
        ax.axhline(0, color="black", linewidth=0.8)
        ax.set_title(f"{response} ← {impulse}")
        plot_idx += 1

for ax in axes[plot_idx:]:
    ax.set_visible(False)

plt.tight_layout()
plt.show()

fevd = var_model.fevd(10)
responses = var_model.names
impulses = var_model.names

ncols = 4
n_plots = len(responses) * len(impulses)
nrows = (n_plots + ncols - 1) // ncols

fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=(16, nrows * 3))
axes = axes.flatten()

plot_idx = 0
for impulse in impulses:
    for response in responses:
        ax = axes[plot_idx]
        data = fevd.decomp[:, responses.index(response), impulses.index(impulse)]
        ax.plot(np.arange(len(data)), data, color="C1")
        ax.axhline(0, color="black", linewidth=0.8)
        ax.set_ylim(0, 1)
        ax.set_title(f"{response} ← {impulse}")
        plot_idx += 1

for ax in axes[plot_idx:]:
    ax.set_visible(False)

plt.tight_layout()
plt.show()

forecast = var_model.forecast(df.values[-3:], steps=12)

forecast_df = pd.DataFrame(
    forecast,
    columns=df.columns,
    index=pd.date_range(start=df.index[-1] + pd.offsets.MonthEnd(), periods=12, freq='M')
)

forecast_df

print("ADF Test Results (Before Transformation):")
adf_results = {}
for col in df.columns:
    result = adfuller(df[col].dropna())
    adf_results[col] = result[1]
    print(f"{col}: p-value = {result[1]:.4f}")

for col in df.columns:
    if (df[col] > 0).all() and adf_results[col] > 0.05:
        df[col] = np.log(df[col])
        print(f"Applied log transform to {col}")

print("\nADF Test Results (After Log Transform):")
for col in df.columns:
    result = adfuller(df[col].dropna())
    print(f"{col}: p-value = {result[1]:.4f}")

for col in df.columns:
    result = adfuller(df[col].dropna())
    if result[1] > 0.05:
        df[col] = df[col].diff().dropna()
        print(f"Differenced {col}")

df = df.dropna()
print("\nStationarity transformation complete.")

max_lags = 12
model = VAR(df)

for i in range(1, max_lags + 1):
    result = model.fit(i)
    print(f"Lag Order = {i}")
    print(f"AIC : {result.aic}")
    print(f"BIC : {result.bic}")
    print(f"HQIC: {result.hqic}")
    print("-"*30)

var_model = VAR(df)
var_results = var_model.fit(maxlags=6)

# In-sample fitted values
in_sample_forecast = var_results.fittedvalues

# Out-of-sample forecast
forecast_array = var_results.forecast(df.values[-var_results.k_ar:], steps=12)
forecast_index = pd.date_range(start=df.index[-1] + pd.offsets.MonthEnd(1), periods=12, freq='M')
forecast_df = pd.DataFrame(forecast_array, index=forecast_index, columns=df.columns)

plt.figure(figsize=(12,6))
plt.plot(df['SP500_Returns'], label='Actual SP500', color='blue')
plt.plot(in_sample_forecast['SP500_Returns'], label='Fitted SP500 (In-sample)', linestyle='--', color='yellow')
plt.plot(forecast_df['SP500_Returns'], label='Forecasted SP500 (Out-of-sample)', linestyle='--', color='red')
plt.title('SP500 Returns: Actual, In-sample Fit, and Forecast')
plt.xlabel('Date')
plt.ylabel('SP500 Returns')
plt.legend()
plt.show()

# Durbin-Watson test for autocorrelation
out = durbin_watson(var_results.resid)
for col, val in zip(df.columns, out):
    print(f'{col}: {val:.2f}')

# Jarque-Bera test for normality
jb_test = stats.jarque_bera(var_results.resid)
print("\nJarque-Bera Test (Normality):", jb_test)

stability = var_results.is_stable()
print("VAR model is stable:", stability)
print(var_results.roots)

print(var_results.summary())

# In-sample evaluation
rmse_in_sample = {}
mae_in_sample = {}

for col in df.columns:
    rmse_in_sample[col] = np.sqrt(mean_squared_error(df[col][var_results.k_ar:],
                                                     in_sample_forecast[col]))
    mae_in_sample[col] = mean_absolute_error(df[col][var_results.k_ar:],
                                             in_sample_forecast[col])

print("In-sample RMSE:")
for col, val in rmse_in_sample.items():
    print(f"{col}: {val:.4f}")

print("\nIn-sample MAE:")
for col, val in mae_in_sample.items():
    print(f"{col}: {val:.4f}")